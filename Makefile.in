REBAR = @ESCRIPT@ $(shell echo ./rebar3)
INSTALL = @INSTALL@
SED = @SED@
ERL = @ERL@

prefix = @prefix@
exec_prefix = @exec_prefix@

DESTDIR =

# /etc/ejabberd/
ETCDIR = $(DESTDIR)@sysconfdir@/ejabberd

# /bin/
BINDIR = $(DESTDIR)@bindir@

# /sbin/
SBINDIR = $(DESTDIR)@sbindir@

# /lib/
LIBDIR =  $(DESTDIR)@libdir@

# /lib/ejabberd/
EJABBERDDIR = $(DESTDIR)@libdir@/ejabberd

# /share/doc/ejabberd
PACKAGE_TARNAME = @PACKAGE_TARNAME@
datarootdir = @datarootdir@
DOCDIR = $(DESTDIR)@docdir@

# /usr/lib/ejabberd/ebin/
BEAMDIR = $(EJABBERDDIR)/ebin

# /usr/lib/ejabberd/include/
INCLUDEDIR = $(EJABBERDDIR)/include

# /usr/lib/ejabberd/priv/
PRIVDIR = $(EJABBERDDIR)/priv

# /usr/lib/ejabberd/priv/bin
PBINDIR = $(PRIVDIR)/bin

# /usr/lib/ejabberd/priv/lib
SODIR = $(PRIVDIR)/lib

# /usr/lib/ejabberd/priv/xml
XMLDIR = $(PRIVDIR)/xml

# /usr/lib/ejabberd/priv/data
DATADIR = $(PRIVDIR)/data

# /usr/lib/ejabberd/priv/msgs
MSGSDIR = $(PRIVDIR)/msgs

# /usr/lib/ejabberd/priv/css
CSSDIR = $(PRIVDIR)/css

# /usr/lib/ejabberd/priv/img
IMGDIR = $(PRIVDIR)/img

# /usr/lib/ejabberd/priv/js
JSDIR = $(PRIVDIR)/js

# /usr/lib/ejabberd/priv/sql
SQLDIR = $(PRIVDIR)/sql

# /usr/lib/ejabberd/priv/lua
LUADIR = $(PRIVDIR)/lua

# /usr/lib/ejabberd/priv/dtl
DTLDIR = $(PRIVDIR)/dtl

# /var/lib/ejabberd/
SPOOLDIR = $(DESTDIR)@localstatedir@/lib/ejabberd

# /var/lock/ejabberdctl
CTLLOCKDIR = $(DESTDIR)@localstatedir@/lock/ejabberdctl

# /var/lib/ejabberd/.erlang.cookie
COOKIEFILE = $(SPOOLDIR)/.erlang.cookie

# /var/log/ejabberd/
LOGDIR = $(DESTDIR)@localstatedir@/log/ejabberd

CTL_TEMPLATE = ejabberdctl.template

INSTALLUSER=@INSTALLUSER@
# if no user was enabled, don't set privileges or ownership
ifeq ($(INSTALLUSER),)
  O_USER=
  G_USER=
  CHOWN_COMMAND=echo
  CHOWN_OUTPUT=/dev/null
  INIT_USER=root
else
  O_USER=-o $(INSTALLUSER)
  G_USER=-g $(INSTALLUSER)
  CHOWN_COMMAND=chown
  CHOWN_OUTPUT=&1
  INIT_USER=$(INSTALLUSER)
endif
# if no group was enabled, don't set privileges or ownership
INSTALLGROUP=@INSTALLGROUP@
ifneq ($(INSTALLGROUP),)
  G_USER=-g $(INSTALLGROUP)
endif

DEPSBASE=_build
DEPSDIR=$(DEPSBASE)/default/lib
DEPSPATTERN="s/ (.*//; /^ / s/.* \([a-z0-9_]*\).*/\1/p;"

all: deps src

deps: $(DEPSDIR)/.got

$(DEPSDIR)/.got:
	rm -rf $(DEPSDIR)/.got
	rm -rf $(DEPSDIR)/.built
	mkdir -p $(DEPSDIR)
	$(REBAR) upgrade && :> $(DEPSDIR)/.got

$(DEPSDIR)/.built: $(DEPSDIR)/.got
	$(REBAR) compile && :> $(DEPSDIR)/.built

src: $(DEPSDIR)/.built
	$(REBAR) compile

update:
	rm -rf $(DEPSDIR)/.got
	rm -rf $(DEPSDIR)/.built
	$(REBAR) upgrade && :> $(DEPSDIR)/.got

xref: all
	$(REBAR) xref

hooks: all
	tools/hook_deps.sh $(DEPSDIR)/ejabberd/ebin

options: all
	tools/opt_types.sh ejabberd_option ebin

translations:
	tools/prepare-tr.sh

edoc:
	$(ERL) -noinput +B -eval \
        'case edoc:application(ejabberd, ".", []) of ok -> halt(0); error -> halt(1) end.'

JOIN_PATHS=$(if $(wordlist 2,1000,$(1)),$(firstword $(1))/$(call JOIN_PATHS,$(wordlist 2,1000,$(1))),$(1))

VERSIONED_DEP=$(if $(DEP_$(1)_VERSION),$(DEP_$(1)_VERSION),$(1))

DEPIX:=$(words $(subst /, ,$(DEPSDIR)))
LIBIX:=$(shell expr "$(DEPIX)" + 2)

ELIXIR_TO_DEST=$(LIBDIR) $(call VERSIONED_DEP,$(word 2,$(1))) $(wordlist 5,1000,$(1))
DEPS_TO_DEST=$(LIBDIR) $(call VERSIONED_DEP,$(word 2,$(1))) $(wordlist 3,1000,$(1))
MAIN_TO_DEST=$(LIBDIR) $(call VERSIONED_DEP,ejabberd) $(1)
TO_DEST_SINGLE=$(if $(subst X$(DEPSBASE)X,,X$(word 1,$(1))X),$(call MAIN_TO_DEST,$(1)),$(if $(subst XlibX,,X$(word $(LIBIX),$(1))X),$(call DEPS_TO_DEST,$(wordlist $(DEPIX),1000,$(1))),$(call ELIXIR_TO_DEST,$(wordlist $(DEPIX),1000,$(1)))))
TO_DEST=$(foreach path,$(1),$(call JOIN_PATHS,$(call TO_DEST_SINGLE,$(subst /, ,$(path)))))

FILTER_DIRS=$(foreach path,$(1),$(if $(wildcard $(path)/*),,$(path)))
FILES_WILDCARD=$(call FILTER_DIRS,$(foreach w,$(1),$(wildcard $(w))))

ifeq ($(MAKECMDGOALS),copy-files-sub)

DEPS:=$(sort $(shell QUIET=1 $(REBAR) tree|$(SED) -ne $(DEPSPATTERN) ))

DEPS_FILES=$(call FILES_WILDCARD,$(foreach DEP,$(DEPS),$(DEPSDIR)/$(DEP)/ebin/*.beam $(DEPSDIR)/$(DEP)/ebin/*.app $(DEPSDIR)/$(DEP)/priv/* $(DEPSDIR)/$(DEP)/priv/lib/* $(DEPSDIR)/$(DEP)/priv/bin/* $(DEPSDIR)/$(DEP)/include/*.hrl $(DEPSDIR)/$(DEP)/COPY* $(DEPSDIR)/$(DEP)/LICENSE* $(DEPSDIR)/$(DEP)/lib/*/ebin/*.beam $(DEPSDIR)/$(DEP)/lib/*/ebin/*.app))

BINARIES=$(DEPSDIR)/eimp/priv/bin/eimp $(DEPSDIR)/fs/priv/mac_listener

DEPS_FILES_FILTERED=$(filter-out $(BINARIES) $(DEPSDIR)/elixir/ebin/elixir.app,$(DEPS_FILES))
DEPS_DIRS=$(sort $(DEPSDIR)/ $(foreach DEP,$(DEPS),$(DEPSDIR)/$(DEP)/) $(dir $(DEPS_FILES)))

MAIN_FILES=$(filter-out %/configure.beam,$(call FILES_WILDCARD,$(DEPSDIR)/ejabberd/ebin/*.beam $(DEPSDIR)/ejabberd/ebin/*.app priv/xml/*.xml priv/lua/*.lua priv/dtl/* priv/data/* priv/data/share_post/* priv/msgs/* priv/css/*.css priv/img/*.png priv/js/*.js priv/lib/* include/*.hrl COPYING))
MAIN_DIRS=$(sort $(dir $(MAIN_FILES)) priv/bin priv/sql)

define DEP_VERSION_template
DEP_$(1)_VERSION:=$(shell $(SED) -e '/vsn/!d;s/.*, *"/$(1)-/;s/".*//' $(2) 2>/dev/null)
endef

DELETE_TARGET_SO=$(if $(subst X.soX,,X$(suffix $(1))X),,rm -f $(call TO_DEST,$(1));)

$(foreach DEP,$(DEPS),$(eval $(call DEP_VERSION_template,$(DEP),$(DEPSDIR)/$(DEP)/ebin/$(DEP).app)))
$(eval $(call DEP_VERSION_template,ejabberd,$(DEPSDIR)/ejabberd/ebin/ejabberd.app))

define COPY_template
$(call TO_DEST,$(1)): $(1) $(call TO_DEST,$(dir $(1))) ; $(call DELETE_TARGET_SO, $(1)) $$(INSTALL) -m 644 $(1) $(call TO_DEST,$(1))
endef

define COPY_BINARY_template
$(call TO_DEST,$(1)): $(1) $(call TO_DEST,$(dir $(1))) ; rm -f $(call TO_DEST,$(1)); $$(INSTALL) -m 755 $$(O_USER) $(1) $(call TO_DEST,$(1))
endef

$(foreach file,$(DEPS_FILES_FILTERED) $(MAIN_FILES),$(eval $(call COPY_template,$(file))))

$(foreach file,$(BINARIES),$(eval $(call COPY_BINARY_template,$(file))))

$(sort $(call TO_DEST,$(MAIN_DIRS) $(DEPS_DIRS))):
	$(INSTALL) -d $@

$(call TO_DEST,priv/sql/lite.sql): sql/lite.sql $(call TO_DEST,priv/sql)
	$(INSTALL) -m 644 $< $@

$(call TO_DEST,priv/bin/captcha.sh): tools/captcha.sh $(call TO_DEST,priv/bin)
	$(INSTALL) -m 755 $(O_USER) $< $@

copy-files-sub2: $(call TO_DEST,$(DEPS_FILES) $(MAIN_FILES) priv/bin/captcha.sh priv/sql/lite.sql)

.PHONY: $(call TO_DEST,$(DEPS_FILES) $(MAIN_DIRS) $(DEPS_DIRS))

endif

copy-files:
	$(MAKE) copy-files-sub

copy-files-sub: copy-files-sub2

install: copy-files
	#
	# Configuration files
	$(INSTALL) -d -m 750 $(G_USER) $(ETCDIR)
	$(INSTALL) -b -S .bak -m 640 $(G_USER) ejabberd.yml $(ETCDIR)/ejabberd.yml
	#[ -f $(ETCDIR)/ejabberd.yml ] \
	#	&& $(INSTALL) -b -m 640 $(G_USER) ejabberd.yml.example $(ETCDIR)/ejabberd.yml-new \
	#	|| $(INSTALL) -b -m 640 $(G_USER) ejabberd.yml.example $(ETCDIR)/ejabberd.yml
	$(SED) -e "s*{{rootdir}}*@prefix@*g" \
		-e "s*{{installuser}}*@INSTALLUSER@*g" \
		-e "s*{{bindir}}*@bindir@*g" \
		-e "s*{{libdir}}*@libdir@*g" \
		-e "s*{{sysconfdir}}*@sysconfdir@*g" \
		-e "s*{{localstatedir}}*@localstatedir@*g" \
		-e "s*{{logdir}}*$(LOGDIR)*g" \
		-e "s*{{docdir}}*@docdir@*g" \
		-e "s*{{erl}}*@ERL@*g" \
		-e "s*{{epmd}}*@EPMD@*g" $(CTL_TEMPLATE) \
		> ejabberdctl.example
	$(INSTALL) -b -S .bak -m 640 $(G_USER) ejabberdctl.cfg.example $(ETCDIR)/ejabberdctl.cfg
	#[ -f $(ETCDIR)/ejabberdctl.cfg ] \
	#	&& $(INSTALL) -b -m 640 $(G_USER) ejabberdctl.cfg.example $(ETCDIR)/ejabberdctl.cfg-new \
	#	|| $(INSTALL) -b -m 640 $(G_USER) ejabberdctl.cfg.example $(ETCDIR)/ejabberdctl.cfg
	$(INSTALL) -b -S .bak -m 644 $(G_USER) inetrc $(ETCDIR)/inetrc

	# Setup hotswap folder. This craetes the hotswap folder where we can put modified code.
	$(INSTALL) -d $(LIBDIR)/zzz_hotswap/ebin

	#
	# Administration script
	[ -d $(SBINDIR) ] || $(INSTALL) -d -m 755 $(SBINDIR)
	$(INSTALL) -m 555 $(G_USER) ejabberdctl.example $(SBINDIR)/ejabberdctl
ifeq ($(shell uname -s),Linux)
	ln -f -s $(SBINDIR)/ejabberdctl /usr/bin/ejabberdctl
endif
ifeq ($(shell uname -s),Darwin)
	ln -f -s $(SBINDIR)/ejabberdctl /usr/local/bin/ejabberdctl
endif
	# Elixir binaries
	[ -d $(BINDIR) ] || $(INSTALL) -d -m 755 $(BINDIR)
	[ -f $(DEPSDIR)/elixir/bin/iex ] && $(INSTALL) -m 550 $(G_USER) $(DEPSDIR)/elixir/bin/iex $(BINDIR)/iex || true
	[ -f $(DEPSDIR)/elixir/bin/elixir ] && $(INSTALL) -m 550 $(G_USER) $(DEPSDIR)/elixir/bin/elixir $(BINDIR)/elixir || true
	[ -f $(DEPSDIR)/elixir/bin/mix ] && $(INSTALL) -m 550 $(G_USER) $(DEPSDIR)/elixir/bin/mix $(BINDIR)/mix || true
	#
	# Init script
	$(SED) -e "s*@ctlscriptpath@*$(SBINDIR)*g" \
		-e "s*@installuser@*$(INIT_USER)*g" ejabberd.init.template \
		> ejabberd.init
	chmod 755 ejabberd.init
	#
	# Service script
	$(SED) -e "s*@ctlscriptpath@*$(SBINDIR)*g" ejabberd.service.template \
		> ejabberd.service
	chmod 644 ejabberd.service
	#
	# Spool directory
	$(INSTALL) -d -m 750 $(O_USER) $(SPOOLDIR)
	$(CHOWN_COMMAND) -R @INSTALLUSER@ $(SPOOLDIR) >$(CHOWN_OUTPUT)
	chmod -R 750 $(SPOOLDIR)
	[ ! -f $(COOKIEFILE) ] || { $(CHOWN_COMMAND) @INSTALLUSER@ $(COOKIEFILE) >$(CHOWN_OUTPUT) ; chmod 400 $(COOKIEFILE) ; }
	#
	# ejabberdctl lock directory
	$(INSTALL) -d -m 750 $(O_USER) $(CTLLOCKDIR)
	$(CHOWN_COMMAND) -R @INSTALLUSER@ $(CTLLOCKDIR) >$(CHOWN_OUTPUT)
	chmod -R 750 $(CTLLOCKDIR)
	#
	# Log directory
	$(INSTALL) -d -m 750 $(O_USER) $(LOGDIR)
	$(CHOWN_COMMAND) -R @INSTALLUSER@ $(LOGDIR) >$(CHOWN_OUTPUT)
	chmod -R 755 $(LOGDIR)
	## TODO(murali@): Fix this eventually, when we have different user profiles.
	## FIXME(Nikola): This is tied to production, breaks when you try make install on localhost.
	## Commented it for now until I figure out what to do.
	#ln -f -s $(LOGDIR) /home/ec2-user/logs
	#
	# Documentation
	$(INSTALL) -d $(DOCDIR)
	[ -f doc/guide.html ] \
		&& $(INSTALL) -m 644 doc/guide.html $(DOCDIR) \
		|| echo "Documentation not included in sources"
	$(INSTALL) -m 644 COPYING $(DOCDIR)

uninstall: uninstall-binary

uninstall-binary:
	rm -f  $(SBINDIR)/ejabberdctl
	rm -f  $(BINDIR)/iex
	rm -f  $(BINDIR)/elixir
	rm -f  $(BINDIR)/mix
	rm -fr $(DOCDIR)
	rm -f  $(BEAMDIR)/*.beam
	rm -f  $(BEAMDIR)/*.app
	rm -fr $(BEAMDIR)
	rm -f  $(INCLUDEDIR)/*.hrl
	rm -fr $(INCLUDEDIR)
	rm -fr $(PBINDIR)
	rm -f  $(SODIR)/*.so
	rm -fr $(SODIR)
	rm -f  $(XMLDIR)/*.xml
	rm -fr $(XMLDIR)
	rm -f  $(DATADIR)/*.data
	rm -fr $(DATADIR)
	rm -f  $(MSGSDIR)/*.msg
	rm -fr $(MSGSDIR)
	rm -f  $(CSSDIR)/*.css
	rm -fr $(CSSDIR)
	rm -f  $(IMGDIR)/*.png
	rm -fr $(IMGDIR)
	rm -f  $(JSDIR)/*.js
	rm -fr $(JSDIR)
	rm -f  $(SQLDIR)/*.sql
	rm -fr $(SQLDIR)
	rm -fr $(LUADIR)/*.lua
	rm -fr $(LUADIR)
	rm -fr $(DTLDIR)/*.dtl
	rm -fr $(DTLDIR)
	rm -fr $(PRIVDIR)
	rm -fr $(EJABBERDDIR)

uninstall-all: uninstall-binary
	rm -rf $(ETCDIR)
	rm -rf $(EJABBERDDIR)
	rm -rf $(SPOOLDIR)
	rm -rf $(CTLLOCKDIR)
	rm -rf $(LOGDIR)

clean:
	rm -rf $(DEPSDIR)/.got
	rm -rf $(DEPSDIR)/.built
	rm -rf test/*.beam
	rm -rf _build/test/
	rm -rf src/proto/*.erl
	rm -rf include/proto/*.hrl
	$(REBAR) clean

clean-rel:
	rm -rf rel/ejabberd

distclean: clean clean-rel
	rm -f config.status
	rm -f config.log
	rm -rf autom4te.cache
	rm -rf _build
	rm -f Makefile
	rm -f vars.config
	rm -f src/ejabberd.app.src
	rm -rf ejabberdctl.example ejabberd.init ejabberd.service
	[ ! -f ../ChangeLog ] || rm -f ../ChangeLog

rel: all
	$(REBAR) generate

TAGS:
	etags *.erl

Makefile: Makefile.in

deps := $(wildcard $(DEPSDIR)/*/ebin)

dialyzer/erlang.plt:
	@mkdir -p dialyzer
	@dialyzer --build_plt --output_plt dialyzer/erlang.plt \
	-o dialyzer/erlang.log --apps kernel stdlib sasl crypto \
	public_key ssl mnesia inets odbc compiler erts \
	os_mon asn1 syntax_tools; \
	status=$$? ; if [ $$status -ne 2 ]; then exit $$status; else exit 0; fi

dialyzer/deps.plt:
	@mkdir -p dialyzer
	@dialyzer --build_plt --output_plt dialyzer/deps.plt \
	-o dialyzer/deps.log $(deps); \
	status=$$? ; if [ $$status -ne 2 ]; then exit $$status; else exit 0; fi

dialyzer/ejabberd.plt:
	@mkdir -p dialyzer
	@dialyzer --build_plt --output_plt dialyzer/ejabberd.plt \
	-o dialyzer/ejabberd.log ebin; \
	status=$$? ; if [ $$status -ne 2 ]; then exit $$status; else exit 0; fi

erlang_plt: dialyzer/erlang.plt
	@dialyzer --plt dialyzer/erlang.plt --check_plt -o dialyzer/erlang.log; \
	status=$$? ; if [ $$status -ne 2 ]; then exit $$status; else exit 0; fi

deps_plt: dialyzer/deps.plt
	@dialyzer --plt dialyzer/deps.plt --check_plt -o dialyzer/deps.log; \
	status=$$? ; if [ $$status -ne 2 ]; then exit $$status; else exit 0; fi

ejabberd_plt: dialyzer/ejabberd.plt
	@dialyzer --plt dialyzer/ejabberd.plt --check_plt -o dialyzer/ejabberd.log; \
	status=$$? ; if [ $$status -ne 2 ]; then exit $$status; else exit 0; fi

dialyzer: erlang_plt deps_plt ejabberd_plt
	@dialyzer --plts dialyzer/*.plt --no_check_plt \
	--get_warnings -o dialyzer/error.log ebin; \
	status=$$? ; if [ $$status -ne 2 ]; then exit $$status; else exit 0; fi

fetchpb:
	rm -rf deps/schemas && git clone git@github.com:HalloAppInc/schemas.git deps/schemas
	cd deps/schemas && make server && cd ../..
	cp deps/schemas/build/server.proto proto/
	cp deps/schemas/build/log_events.proto proto/
	cp deps/schemas/build/clients.proto proto/
	rm -rf deps/schemas


translate:
	# creates temporary directories to work with.
	rm -rf temp
	mkdir -p temp
	mkdir -p temp/msgs
	mkdir -p priv/msgs
	# clone ios repo
	git clone git@github.com:HalloAppInc/halloapp-ios.git temp/halloapp-ios
	# copies all translation strings related folders.
	find temp/halloapp-ios/Halloapp/*.lproj -type d | xargs -I{} cp -r {} temp/msgs/
	# deletes all files except the files that contain the exact translations.
	find temp/msgs/*.lproj -type f ! -name 'Localizable.strings' -delete
	rm -rf temp/msgs/Base.lproj temp/msgs/en.lproj
	# rename all files to be 'langId.strings'
	cd temp/msgs/ && for subdir in *; do mv -v $$subdir $${subdir//.lproj/}; done;
	cd temp/msgs/ && for subdir in *; do mv $$subdir/Localizable.strings $$subdir.txt; done;
	cd temp/msgs/ && rm -r */;
	# filter out all server translations and delete the rest of the lines.
	cd temp/msgs/ && for file in *; do grep '\"server.*' $$file > $$file.strings; done;
	# remove any other files if any.
	find temp/msgs/ -type f ! -name '*.strings' -delete;
	cd temp/msgs/ && for file in *; do mv -v $$file $${file//.txt.strings/.strings}; done;
	# move them to the msgs directory.
	cp temp/msgs/* priv/msgs/
	# cleanup.
	rm -rf temp


invite-strings:
	rm -rf temp
	mkdir -p temp/msgs
	mkdir -p priv/data
	# clone ios repo
	git clone git@github.com:HalloAppInc/halloapp-ios.git temp/halloapp-ios
	# copies all translation strings related folders.
	find temp/halloapp-ios/Halloapp/*.lproj -type d | xargs -I{} cp -r {} temp/msgs/
	# deletes all files except the files that contain the exact translations.
	find temp/msgs/*.lproj -type f ! -name 'Localizable.strings' -delete
	rm -rf temp/msgs/Base.lproj temp/msgs/en.lproj
	# rename all files to be 'langId.strings'
	cd temp/msgs/ && for subdir in *; do mv -v $$subdir $${subdir//.lproj/}; done;
	cd temp/msgs/ && for subdir in *; do mv $$subdir/Localizable.strings $$subdir.txt; done;
	cd temp/msgs/ && rm -r */;
	# filter out all invite string translations and delete the rest of the lines.
	cd temp/msgs/ && for file in *; do grep '\"invite.text*' $$file | cut -d '"' -f 4 > $$file.strings; done;
	# remove any other files if any.
	find temp/msgs/ -type f ! -name '*.strings' -delete;
	touch temp/invite_strings.json
	echo "{" >> temp/invite_strings.json
	# first, format each .string file into a new file .string2
	# then, cat these formatted files into a json output file
	cd temp/msgs/ && for file in *; do \
		while read -r line; do \
			printf '  "%s",\n' "$$line" >> `echo $${file}2` ; done < $${file}; \
		truncate -s-2 $${file}2; \
		printf '%s: [\n%s\n],\n' "\"`echo $${file//.txt.strings}`\"" "`cat $${file}2`" >> ../invite_strings.json; done;
	# truncate last comma character from file
	truncate -s-2 temp/invite_strings.json
	echo "\n}" >> temp/invite_strings.json
	# move the file to the data directory.
	cp temp/invite_strings.json priv/data/
	# cleanup.
	rm -rf temp


phone-metadata:
	# remove pager
	sed -i '' '/pager\>/,/\/pager\>/{/^\pager\>/!{/^\/pager\>/!d;};}' priv/xml/PhoneNumberMetadata.xml
	# remove tollFree
	sed -i '' '/tollFree\>/,/\/tollFree\>/{/^\tollFree\>/!{/^\/tollFree\>/!d;};}' priv/xml/PhoneNumberMetadata.xml
	# remove premiumRate
	sed -i '' '/premiumRate\>/,/\/premiumRate\>/{/^\premiumRate\>/!{/^\/premiumRate\>/!d;};}' priv/xml/PhoneNumberMetadata.xml
	# remove sharedCost
	sed -i '' '/sharedCost\>/,/\/sharedCost\>/{/^\sharedCost\>/!{/^\/sharedCost\>/!d;};}' priv/xml/PhoneNumberMetadata.xml
	# remove personalNumber
	sed -i '' '/personalNumber\>/,/\/personalNumber\>/{/^\personalNumber\>/!{/^\/personalNumber\>/!d;};}' priv/xml/PhoneNumberMetadata.xml
	# remove uan
	sed -i '' '/uan\>/,/\/uan\>/{/^\uan\>/!{/^\/uan\>/!d;};}' priv/xml/PhoneNumberMetadata.xml
	# remove voicemail
	sed -i '' '/voicemail\>/,/\/voicemail\>/{/^\voicemail\>/!{/^\/voicemail\>/!d;};}' priv/xml/PhoneNumberMetadata.xml


eunit:
ifeq ($(MODULE),)
	HALLO_ENV=test $(REBAR) eunit
else
	HALLO_ENV=test $(REBAR) eunit --module=$(MODULE)
endif

ct:
ifeq ($(MODULE),)
	HALLO_ENV=test $(REBAR) ct --suite=test/ha_SUITE
else
	HALLO_ENV=test $(REBAR) ct --suite=test/ha_SUITE --group=$(MODULE)
endif

test: eunit ct

run: src
	HALLO_ENV=localhost EJABBERD_CONFIG_PATH=ejabberd.yml erl -kernel shell_history enabled -pa _build/default/lib/*/ebin -s ejabberd

.PHONY: src edoc dialyzer Makefile TAGS clean clean-rel distclean rel \
	install uninstall uninstall-binary uninstall-all translations deps test \
	quicktest erlang_plt deps_plt ejabberd_plt xref hooks options eunit ct

